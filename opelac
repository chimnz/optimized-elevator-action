#!/usr/bin/env python3 -B
from numpy import loadtxt, mean, array
import sys, io, random
from string import ascii_lowercase as chars

try:
    if not sys.stdin.isatty():                                   # if stdin is not interactive (proper piping or input redirection occured)
        CALLS = io.StringIO('\n'.join(line.strip() for line in sys.stdin))
        sys.stdin.flush(); sys.stdout.flush()
    else:
        raise Exception
except:
    exit('usage: [CALLS] | opelac\nor: opelac < [CALLS_FILE]')

data = loadtxt(fname=CALLS, dtype=('i'))                    # load data into 2D array: [(t, a, b), ...]
calls = {t: (a,b) for t,a,b in data}                        # hash map => {t: (a, b)}

elv = {
    'y': 1,                                                 # init_pos
    'riders': {},                                           # hash map => {rider: True}
    'dest': 1,
    'backlog': []                                           # 
}

picks = {}                                                  # {a: [rider, ...]}
dest = {}                                                   # {rider: b}
drops = {}                                                  # {b: [rider, ...]}

distance = lambda y: abs( y - elv['y'] )
rider = lambda: ''.join(random.choice(chars) for i in range(7))

t = 0
def move():                                                 # move toward destination at 1 floor/second
    global t
    stop, y = elv['dest'], elv['y']
    dt = 1
    if stop == y:
        dy = 0
    elif stop > y:
        dy = 1
    elif stop < y:
        dy = -1
    elv['y'] += dy; t += dt

def respond(call):
    r = rider()                                             # unique rider for each call (r)
    ##print('(t: {}, person: {}) CALL'.format(t, r))
    a, b = call                                             
    picks[a] = picks.get(a, []) + [r]                       # at (a), pickup (r)
    dest[r] = b                                             # (r) is going to (b)
    elv['dest'] = a                                         # set current destination to (a)
    #NOTE: what if this is another call that came while elv already responding to a call? what should elv dest change to?

delay = 0
def pickup(pick):
    for r in pick:
        elv['riders'][r] = True                             # new rider steps into elevator
        b = dest[r]
        drops[b] = drops.get(b, []) + [r]                   # at (b), dropoff (r)
    ##print('(t: {}) (person: {}) (y: {}) (r: {}) PICK'.format(t, pick, elv['y'], elv['riders']))
    elv['dest'] = dest[r]                                   # start heading towards new destination (b)
    #NOTE: what about if two riders make call within short enough period such that two are waiting to get picked up? where does elv go?

def dropoff(drop):
    ##print('(t: {}) (person: {}) (y: {}) (r: {}) DROP'.format(t, drop, elv['y'], elv['riders']))
    for r in drop:
        elv['riders'].pop(r)                                # departing rider steps out of elevator
    elv['dest'] = elv['y']                                  # elevator remains at current position until next call
    #NOTE what if another call came in before this dropoff?

C = P = D = 0
while t <= 1100:
    y = elv['y']
    if calls.get(t):                                        # check if call was made at current time
        respond( calls.pop(t) ); C += 1
    if picks.get(y):                                        # check if rider(s) needs to be picked up at current position
        pickup( picks.pop(y) ); P += 1
    if drops.get(y):                                        # check if rider(s) needs to be dropped off at current position  
        dropoff( drops.pop(y) ); D += 1         
    move()
print('C: {} P: {} D: {}'.format(C, P, D))