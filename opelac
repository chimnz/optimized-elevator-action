#!/usr/bin/python3 -B
from numpy import loadtxt, mean, array
from sys import argv

CALLS_FILE = argv[1]  									# path to input file => {time} {floor} {dest} on each line
OUT_FILE = argv[2]										# path to output file
ACTION_TEMP = "TIME {:.2f}\t{} FLOOR {}"				# action (goto) msg template string
STAT_TEMP = "AVERAGE {} TIME: {:.2f}"
OUT_TEMP = "[START FLOOR {}]\n{}\n[END FLOOR {}]"
INITIAL_POS = 1											# elevator starts on floor 1
MOVE_SPEED = 1											# 1 floor/second

# load CALLS_FILE data into calls list sorted by time
dtype = [('time', 'f'), ('floor', 'i'), ('dest', 'i')]  # "f" is for float, "i" is for integer
calls = loadtxt(fname=CALLS_FILE, dtype=dtype)  		# [(time1, floor1, dest1), (time2, floor2, dest2), ...]
calls = sorted(calls, key=lambda x: x[0])  				# sort calls by time

actions = []				# list to log elevator actions
wait_time = []				# array of pickup time_delta values
inside_time = []			# array of dropoff time_delta values
elapsed_time = calls[0][0]	# the time of the very first call
elevator = {
	'pos': INITIAL_POS
}

def goto(floor, pickup=True):
	global elapsed_time
	action_type = "PICKUP" if pickup else "DROPOFF"
	actions.append( ACTION_TEMP.format(elapsed_time, action_type, floor) )		# log the action to be performed
	current_pos = elevator['pos']

	time_delta = abs(floor - current_pos) / MOVE_SPEED  			# time needed to move from current_pos to floor
	if pickup:
		wait_time.append( time_delta )								# record time rider spent waiting to be picked up
	else:
		inside_time.append( time_delta )							# record time rider spent inside the elevator
	elapsed_time += time_delta										# (1) wait until elevator arrives at floor
	elevator['pos'] = floor											# update elevator position

	time_delta = 30 if floor == 1 else 5							# time needed to pick up or drop off riders
	elapsed_time += time_delta										# (2) wait until finished picking up or dropping off

# sequentially perform pick ups and drop offs
for time, pos, dest in calls:
	if elapsed_time < time:											# if the call has not occured yet
		elapsed_time = time											# wait for call to occur
	goto( pos )														# goto, then pick up at pos
	goto( dest, pickup=False )										# goto, then drop off at dest

# write elevator action time series to stdout
s = OUT_TEMP.format(
	INITIAL_POS, "\n".join(act for act in actions), elevator['pos']
)
with open(OUT_FILE, 'w') as f:
	f.write(s)

# compute stats
wait_time, inside_time = array(wait_time), array(inside_time)
total_time = wait_time + inside_time
data = [ ('WAIT', wait_time), ('INSIDE', inside_time), ('TOTAL', total_time) ]
for time_type, time_delta_array in data:
	mean_value = mean(time_delta_array)
	print( STAT_TEMP.format(time_type, mean_value) )