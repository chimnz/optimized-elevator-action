#!/usr/bin/env python3 -B
from numpy import loadtxt, mean
import sys, io, random, string, yaml

try:
    if '-h' in sys.argv:
        raise
    CONFIG_FILE = sys.argv[1]
    with open(CONFIG_FILE) as f:
        config = yaml.load(f, Loader=yaml.FullLoader)
    CALLS = io.StringIO('\n'.join(line.strip() for line in sys.stdin))
    NUM_SHAFTS = config['NUM_SHAFTS']                           # number of elevators
    CAPACITY = config['CAPACITY']                               # maximum capacity of each elevator
    STATS_MSG = config['templates']['STATS']
    ACTION_MSG = config['templates']['oscillating']['ACTION']
except:
    exit('usage: [CALLS] | opelac\nor: opelac < [CALLS_FILE]')

WAIT = INSIDE = TOTAL = 0                                       # time statistics to be computed

data = loadtxt(fname=CALLS, dtype=('i'))                        # load data into 2D array: [(t, a, b), ...]
calls = {t: (t,a,b) for t,a,b in data}                          # hash map => {t: (t,a, b)}

elv = {
    'y': 1,                                                     # the position of the elevator
    'riders': {},                                               # hash map => {rider: True}
    'delay': 0,                                                 # the amount of time by which elevator movement should be delayed
    'v': 0                                                      # the velocity (speed and direction) of the elevator
}
elv = {idx: elv.copy() for idx in range(NUM_SHAFTS)}            # (NUM_SHAFTS) identical elevators

waiting = {}                                                    # {a: [rider, ...]}
destination = {}                                                # {rider: b}
arriving = {}                                                   # {b: [rider, ...]}
ignore = {idx: {} for idx in range(NUM_SHAFTS)}                 # {idx: {y: True, ...}, ...}

position = lambda idx: elv[idx]['y']                            # get: position of elevator
nriders = lambda idx: len(elv[idx]['riders'])                   # get: number of riders inside elevator
limit = lambda idx: CAPACITY - nriders(idx)                     # get: number of additional riders that can fit inside elevator
npickup = lambda y: len(waiting[y])                             # get: number of people to be riders up at y
velocity = lambda idx: elv[idx]['v']                            # get: velocity of elevator
delayed = lambda idx: elv[idx]['delay']                         # get: remaining time for which the elevator cannot move

# action: ["TIME {};\tSHAFT {}\t FLOOR {}\t{}", ...]
# timestamp: {rider: {"CALL":t, "PICKUP":t,"DROPOFF":t}, ...}
log = {
    'C': 0, 'P': 0, 'D': 0, 'action': [], 'wait': [], 'inside': [], 'timestamp': {}
}

t = 0
delay = 0

def advance():                                                  # move time forward; set next velocity
    global t
    dt = 1
    for idx in range(NUM_SHAFTS):
        pos = position(idx)
        v = velocity(idx)
        if delayed(idx):                                        # performing pickup/dropoff
            v = 0
            elv[idx]['delay'] -= dt
        else:                                                   # not performing pickup/dropoff
            if pos == 1:
                v = 1                                           # change velocity to 1 floor/second
            elif pos == 100:                              
                v = -1                                          # change velocity to -1 floor/second
            else:                                               # position in range (1, 100)
                if v == 0:
                    v = 1
        elv[idx]['v'] = v                                       # set velocity
        elv[idx]['y'] += v                                      # move elevator
    t += dt                                                     # time moves forward no matter what

def rider():                                                    # generate unique rider identifier
    chars = string.ascii_lowercase + string.digits
    r = ''.join(random.choice(chars) for i in range(25))
    return r

def respond(call):
    log['C'] += 1
    r = rider()                                                 # unique rider for each call (r)
    t, a, b = call                                             
    waiting[a] = waiting.get(a, []) + [r]                       # (r) is waiting at (a)
    destination[r] = b                                          # (r) is going to (b)
    log['timestamp'][r] = {'CALL': t}

def pickup(idx, riders):
    global t, delay
    log['action'].append( ACTION_MSG.format(t+delay, idx+1, position(idx), 'PICKUP') )
    for r in riders:
        log['P'] += 1
        elv[idx]['riders'][r] = True                            # rider steps into elevator
        b = destination[r]                                      # rider is going to (b)
        arriving[b] = arriving.get(b, []) + [r]                 # at (b), dropoff (r)
        log['timestamp'][r].update( {'PICKUP': t} )
    assert nriders(idx) <= CAPACITY
    dt = 30 if position(idx) == 1 else 5                        # compensate for time it takes to pick up riders
    delay += dt; elv[idx]['delay'] += dt

def dropoff(idx, riders):
    global delay
    log['action'].append( ACTION_MSG.format(t+delay, idx+1, position(idx), 'DROPOFF') )
    for r in riders:
        log['D'] += 1
        elv[idx]['riders'].pop(r)                               # built-in test: disembark riders by their unique identifer
        log['timestamp'][r].update( {'DROPOFF': t} )
    dt = 30 if position(idx) == 1 else 5                        # compensate for time it takes to drop off riders
    delay += dt; elv[idx]['delay'] += dt
    ignore[idx].clear()                                         # clear ignore table after every dropoff

while calls or waiting or arriving:
    if calls.get(t):                                            # check if call was made at current time)
        respond( calls.pop(t) )
    for idx in range(NUM_SHAFTS):
        y = position(idx)
        if arriving.get(y):                                     # (1) check if rider(s) needs to be dropped off at current position  
            dropoff( idx, arriving.pop(y) )
        if waiting.get(y) and not ignore[idx].get(y):           # (2) check if rider(s) needs to be picked up at current position
            lmt = limit(idx)
            if npickup(y) <= lmt:                               # if there is enough space
                pickup( idx, waiting.pop(y) )                   # pick-up all riders
            else:                                               # if there is not enough space
                pickup( idx, waiting[y][:lmt] )                 # pick up only (lmt) people
                waiting[y] = waiting[y][lmt:]                   # update waiting table
                ignore[idx][y] = True                           # ignore this floor until next dropoff
    advance()

assert all(nriders(idx) == 0 for idx in range(NUM_SHAFTS))
assert len(data) == log['C'] == log['P'] == log['D']

# write action time series to stdout
actions = "\n".join(msg for msg in log['action'])
print("[actions]\n{}\n".format(actions))
# compute stats and write to stdout
wait_times, inside_times = [], [] 
for times in log['timestamp'].values():
    C, P, D = times['CALL'], times['PICKUP'], times['DROPOFF']
    wait_times.append( P - C )
    inside_times.append( D - P )
WAIT, INSIDE = mean(wait_times), mean(inside_times)
TOTAL = WAIT + INSIDE
stats = STATS_MSG.format(WAIT, INSIDE, TOTAL)
print("[stats]\n{}".format(stats))