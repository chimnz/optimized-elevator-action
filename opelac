#!/usr/bin/env python3 -B
from numpy import loadtxt, mean, array
import sys, io, random, string

try:
    if not sys.stdin.isatty():                              # if stdin is not interactive (proper piping or input redirection occured)
        CALLS = io.StringIO('\n'.join(line.strip() for line in sys.stdin))
    else:
        raise Exception
except:
    exit('usage: [CALLS] | opelac\nor: opelac < [CALLS_FILE]')

data = loadtxt(fname=CALLS, dtype=('i'))                    # load data into 2D array: [(t, a, b), ...]
calls = {t: (a,b) for t,a,b in data}                        # hash map => {t: (a, b)}

N = 2                                                       # number of elevators
CAPACITY = 2                                                # maximum capacity of each elevator
elv = {
    'y': 1,
    'riders': {},                                           # hash map => {rider: True}
    ##'delay': 0,                                              # the amount of time by which elevator movement is delayed
    'dy': 1
}
elv = {i: elv.copy() for i in range(N)}                     # N identical elevators

pickup = {}                                                 # {a: [rider, ...]}
dest = {}                                                   # {rider: b}
dropoff = {}                                                # {b: [rider, ...]}

position = lambda idx: elv[idx]['y']
nriders = lambda idx: len(elv[idx]['riders'])               # get number of riders in elevator (idx)
limit = lambda idx: CAPACITY - nriders(idx)                 # get number of additional people that can fit onto elevator
npickup = lambda y: len(pickup[y])                          # get number of people to be picked up at y
##delayed = lambda idx: elv[idx]['delay']              

log = {'C': 0, 'P': 0, 'D': 0}                              # store number of calls, pick-ups, and drop-offs

t = 0
delay = 0

def advance():                                              # move elevators, advance time forward
    global t
    dt = 1
    for idx in range(N):
        dy = elv[idx]['dy']
        if position(idx) == 1:
            dy = 1                                          # move 1 floor/second
        elif position(idx) == 100:
            dy = -1                                         # move at -1 floor/second
        elv[idx]['dy'] = dy
        elv[idx]['y'] += dy
    t += dt                                                 # time moves forward no matter what

def rider():                                                # generate unique rider identifier
    chars = string.ascii_lowercase + string.digits
    r = ''.join(random.choice(chars) for i in range(25))
    return r

def respond(call):
    log['C'] += 1
    r = rider()                                             # unique rider for each call (r)
    a, b = call                                             
    pickup[a] = pickup.get(a, []) + [r]                     # at (a), pick up (r)
    dest[r] = b                                             # (r) is going to (b)

def pick(idx, riders):
    global delay
    for r in riders:
        log['P'] += 1
        elv[idx]['riders'][r] = True                        # new rider steps into elevator
        b = dest[r]                                         # rider is going to (b)
        dropoff[b] = dropoff.get(b, []) + [r]               # at (b), dropoff (r)
    dt = 30 if position(idx) == 1 else 5                    # compensate for time it takes to pick up riders
    delay += dt;
    ##elv[idx]['delay'] += dt

def drop(idx, riders):
    global delay
    for r in riders:
        log['D'] += 1
        elv[idx]['riders'].pop(r)                               # disembark riders by their unique identifer
    dt = 30 if position(idx) == 1 else 5                        # compensate for time it takes to drop off riders
    delay += dt;
    ##elv[idx]['delay'] += dt

while calls or pickup or dropoff:
    if calls.get(t):                                            # check if call was made at current time)
        respond( calls.pop(t) )
    for idx in range(N):
        y = position(idx)
        if dropoff.get(y):                                      # (1) check if rider(s) needs to be dropped off at current position  
            drop( idx, dropoff.pop(y) )
        if pickup.get(y):                                       # (2) check if rider(s) needs to be picked up at current position
            lmt = limit(idx)
            if npickup(y) <= lmt:                               # if there is enough space
                pick( idx, pickup.pop(y) )                      # pick-up all riders
            else:                                               # if there is not enough space
                pick( idx, pickup[y][:lmt] )                    # pick up only (lmt) people
                pickup[y] = pickup[y][lmt:]                     # update pickup table
    advance()

assert all(nriders(idx) == 0 for idx in range(N))
assert log['C'] == log['P'] == log['D']
print('t:', t, 'delay:', delay)