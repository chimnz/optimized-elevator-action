#!/usr/bin/env python3 -B
from numpy import loadtxt, mean, array
import sys, io, random, string

try:
    if not sys.stdin.isatty():                              # if stdin is not interactive (proper piping or input redirection occured)
        CALLS = io.StringIO('\n'.join(line.strip() for line in sys.stdin))
    else:
        raise Exception
except:
    exit('usage: [CALLS] | opelac\nor: opelac < [CALLS_FILE]')

data = loadtxt(fname=CALLS, dtype=('i'))                    # load data into 2D array: [(t, a, b), ...]
calls = {t: (a,b) for t,a,b in data}                        # hash map => {t: (a, b)}

elv = {
    'y': 1,
    'riders': {},                                           # hash map => {rider: True}
    'capacity': 2
}

pickup = {}                                                 # {a: [rider, ...]}
dest = {}                                                   # {rider: b}
dropoff = {}                                                # {b: [rider, ...]}

log = {'C': 0, 'P': 0, 'D': 0}                              # store number of calls, pick-ups, and drop-offs

t = 0
delay = 0
dy = 1

def move():                                                 # elevator is constantly moving from floor 1 to floor 100
    global t, dy
    dt = 1                                                  # move at 1 floor/second
    if elv['y'] == 1:
        dy = 1
    elif elv['y'] == 100:
        dy = -1
    elv['y'] += dy; t += dt

def rider():                                                # generate unique 25 character rider identifier
    chars = string.ascii_lowercase + string.digits
    r = ''.join(random.choice(chars) for i in range(25))
    return r

def respond(call):
    log['C'] += 1
    r = rider()                                             # unique rider for each call (r)
    a, b = call                                             
    pickup[a] = pickup.get(a, []) + [r]                     # at (a), pick up (r)
    dest[r] = b                                             # (r) is going to (b)

def pick(riders):
    global delay
    for r in riders:
        log['P'] += 1
        elv['riders'][r] = True                             # new rider steps into elevator
        b = dest[r]                                         # rider is going to (b)
        dropoff[b] = dropoff.get(b, []) + [r]               # at (b), dropoff (r)
    dt = 30 if elv['y'] == 1 else 5                         # compensate for time it takes to pick up riders
    delay += dt


def drop(riders):
    global delay
    for r in riders:
        log['D'] += 1
        elv['riders'].pop(r)                                # disembark riders by their unique identifer
    dt = 30 if elv['y'] == 1 else 5                         # compensate for time it takes to drop off riders
    delay += dt

while calls or pickup or dropoff:
    y = elv['y']
    if calls.get(t):                                        # check if call was made at current time
        respond( calls.pop(t) )
    if dropoff.get(y):                                      # (1) check if rider(s) needs to be dropped off at current position  
        drop( dropoff.pop(y) )
    if pickup.get(y):                                       # (2) check if rider(s) needs to be picked up at current position
        nriders = len( elv['riders'] )                      # number of people on the elevator
        npickup = len( pickup[y] )                          # number of people who need to be picked up
        limit = elv['capacity'] - nriders
        if npickup <= limit:                                # if there is enough space, pick-up all riders
            pick( pickup.pop(y) )
        else:                                               # if there is not enough space choose riders who will be picked up        
            newriders = pickup[y][:limit]                   # riders that will be emabrking
            pickup[y] = pickup[y][limit:]                   # update pickup table
            pick( newriders )
    move()

assert len( elv['riders'] ) == 0
assert log['C'] == log['P'] == log['D']