#!/usr/bin/python3 -B
from numpy import loadtxt, mean, array
from sys import argv

CALLS_FILE = argv[1]  									# path to input file => {time} {pos} {dest} on each line
OUT_FILE = argv[2]										# path to output file
ACTION_TEMP = "TIME {:.2f}\t{} FLOOR {}"				# action (goto) msg template string
STAT_TEMP = "AVERAGE {} TIME: {:.2f}"
INITIAL_POS = 1											# all shafts start on floor 1
MOVE_SPEED = 1											# 1 floor/second

# load CALLS_FILE data into calls list sorted by time
calls = sorted(loadtxt(
    fname=CALLS_FILE,
    dtype = [('time', 'f'), ('floor', 'i'), ('dest', 'i')]  # "f" is for float, "i" is for integer
), key=lambda x: x[0])

commands = []				                            # calls => commands (FIFO queue of PICKUP AND DROPOFF)
actions = []				                            # list to log elevator actions
wait_time = []				                            # log of time rider spent waiting to be picked up during each call
inside_time = []			                            # log of time rider spent inside elevator during each call
elapsed_time = calls[0][0]	                            # the time of the very first call
elevator = { 'floor': INITIAL_POS }

# convert call time series into command times series
for time, pos, dest in calls:
    commands.append( {'time': time, 'floor': pos, 'action': 'PICKUP'} )
    commands.append( {'time': time, 'floor': dest, 'action': 'DROPOFF'} )

def goto(floor, action):
    global elapsed_time
    tdl = None                                          # "time delta log": the log (list) in which to record wait time or inside time
    if action is 'PICKUP':
        tdl = wait_time
    elif action is 'DROPOFF':
        tdl = inside_time

    # log action that is to be performed at the current (elapsed) time
    actions.append( ACTION_TEMP.format(elapsed_time, action, floor) )

    # simulate moving from current floor to specified floor
    dt1 = abs(floor - elevator['floor']) / MOVE_SPEED  			    # (1) time needed to move from current_pos to floor
    elapsed_time += dt1										        # wait until elevator arrives at floor
    tdl.append( dt1 )							                    # log time delta
    elevator['floor'] = floor										# update elevator position

    # simulate waiting for rider to get on/off
    dt2 = 30 if floor == 1 else 5							        # (2) time needed to pick up or drop off riders
    elapsed_time += dt2										        # wait until finished picking up or dropping off

# process command queue (simulation)
while len(commands) > 0:
    cmd = commands.pop(0)
    hail_time = cmd.pop('time')										# time at which elevator was hailed
    if elapsed_time < hail_time:									# if the call has not occured yet
        elapsed_time = hail_time									# wait for call to occur
    goto(**cmd)

# write action time series to output file
with open(OUT_FILE, 'w') as f:
    s = "\n".join(act for act in actions)
    f.write(s)

# compute stats and write to stdout
wait_time, inside_time = array(wait_time), array(inside_time)
total_time = wait_time + inside_time
data = [ ('WAIT', wait_time), ('INSIDE', inside_time), ('TOTAL', total_time) ]
for time_type, time_delta_array in data:
    mean_value = mean(time_delta_array)
    print( STAT_TEMP.format(time_type, mean_value) )