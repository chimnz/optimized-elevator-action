#!/usr/bin/env python3 -B
from numpy import loadtxt, mean
from yaml import load, FullLoader
from sys import argv, stdin
from io import StringIO

try:
    if '-h' in argv:
        raise
    CONFIG_FILE = argv[1]                                        # parse config file
    with open(CONFIG_FILE) as f:
        config = load(f, Loader=FullLoader)
except:
    exit('usage: [CALLS] | opelac [CONFIG_FILE]\nor: opelac [CONFIG_FILE] < [CALLS_FILE]')
CALLS = StringIO('\n'.join(line for line in stdin))          # read calls time series from stdin
NUM_SHAFTS = int(config['NUM_SHAFTS'])                       # specify number of shafts
INITIAL_POS = int(config['INITIAL_POS'])				     # initial position of all shafts
SPEED = int(config['SPEED'])                                 # shaft speed (floor/second)
STAT_MSG = config['templates']['STATS']
ACTION_MSG = config['templates']['sequential']['ACTION']

TIME = 0                                                    # simulation time
CALL_TIME = 0                                               # time of earliest unanswered call
WAIT = INSIDE = TOTAL = 0                                   # time statistics to be logged

pickup, dropoff = 'PICKUP', 'DROPOFF'                       # the two types of "goto" actions
log = {'action': [], 'wait': [], 'inside': []}

elv = {}                                                    # initalize identical elevator (shaft) states
for i in range(NUM_SHAFTS):
    n = i+1                                                 # shaft number (1, 2, 3, ...)
    elv[n] = { 'pos': INITIAL_POS }

# load data into 2D array
calls = list( loadtxt(fname=CALLS, dtype=('i')) )           # [(t, a, b), ...]: at time (t), I want to go from (a) to (b)

def nearest_shaft(floor):
    distance = lambda n: abs( floor - elv[n]['pos'] )       # given shaft number (n), return distance of shaft (n) from (pos)
    shafts = sorted( elv.keys(), key=distance )             # all shafts sorted by distance releative to pos
    return shafts[0]

def goto(act, n, dest):                                     # move shaft n from its current pos to dest
    global TIME
    pos = elv[n]['pos']                                     # current position of the shaft
    msg = ACTION_MSG.format(TIME, n, pos, dest, act)        # log: action
    log['action'].append( msg )

    dt1 = int( abs(dest-pos) / SPEED )                      # delay #1: shaft is moving
    dt2 = 30 if dest == 1 else 5                            # delay #2: shaft is loading/unloading
    TIME += (dt1 + dt2)
    elv[n]['pos'] = dest                                    # shaft has reached destination

    if act is pickup:                                       # log: wait_time
        begin_time = TIME - CALL_TIME
        wait_time = begin_time + dt1
        log['wait'].append(wait_time)
    elif act is dropoff:                                    # log: inside_time
        inside_time = dt1
        log['inside'].append(dt1)

def answer(call):
    global TIME, CALL_TIME
    t, a, b = call
    CALL_TIME = t                                           # time at which call was made
    if TIME <= t:                                           # if next call has not occured yet
        TIME = t                                            # wait until next call before performing actions
    n = nearest_shaft( a )                                  # choose the nearest shaft to (a)
    goto( pickup, n, a )                                    # perform pickup
    goto( dropoff, n, b )                                   # then dropoff

# process calls list as a FIFO queue
while calls:
    answer( calls.pop(0) )

# write action time series to stdout
actions = "\n".join(msg for msg in log['action'])
print("[actions]\n{}\n".format(actions))
# compute stats and write to stdout
WAIT = mean( log['wait'] )
INSIDE = mean( log['inside'] )
TOTAL = WAIT + INSIDE
stats = STAT_MSG.format(WAIT, INSIDE, TOTAL)
print("[stats]\n{}".format(stats))