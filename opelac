#!/usr/bin/env python3 -B
from numpy import loadtxt, mean, array
import sys, yaml, io, random
from string import ascii_lowercase as chars

try:
    if not sys.stdin.isatty():                                   # if stdin is not interactive (proper piping or input redirection occured)
        CALLS = io.StringIO('\n'.join(line for line in sys.stdin))
    else:
        raise Exception
    CONFIG_FILE = sys.argv[1]
    with open(CONFIG_FILE) as f:
        config = yaml.load(f, Loader=yaml.FullLoader)
    NUM_SHAFTS = int(config['NUM_SHAFTS'])                       # specify number of shafts
    INITIAL_POS = int(config['INITIAL_POS'])				     # initial position of all shafts
    SPEED = int(config['SPEED'])                                 # shaft speed (floor/second)
    ACTION_MSG = config['templates']['ACTION']
    STAT_MSG = config['templates']['STATS']
except:
    exit('usage: [CALLS] | opelac [CONFIG_FILE]\nor: opelac [CONFIG_FILE] < [CALLS_FILE]')

elv = {
    'y': 1,                                                 # initial pos
    'rdrs': {}                                              # hash map => {rider: True}
}
data = loadtxt(fname=CALLS, dtype=('i'))                    # load data into 2D array: [(t, a, b), ...]
calls = {}                                                  # hash map => {t: {pos dest rider}}
for t, a, b in data:
    calls[t] = (a, b)

rider = lambda: ''.join(random.choice(chars) for i in range(7))
distance = lambda pos: abs( pos - elv['y'] )

'''
drops = {}                                              # hash map => {t: {rider}}, (rider will have reached destination and gotten off)
if drops.get(t):                                        # if there are riders to be dropped off at current_floor
    dsmbrk = drop.pop(t)                                # riders who will be getting off on floor y
    for rdr in dsmbrk:
        elv['rdrs'].pop(rdr)                            # powerful: remove rider by unique identifier rather than count
        print('drop {} on {}'.format(rdr, y))
    delay += dt                                         # "wait for drop-off to finish"
'''

t = delay = 0
while calls:
    if calls.get(t):                                        # a call was made at the current time
        a, b = calls.pop(t)                                 # pick-up and drop-off floors
        dy = 1 if a >= elv['y'] else -1                     # moving elevator: choose increment
        while elv['y'] != a:                                # moving elevator: pos -> a (pick-up floor)
            elv['y'] += dy                                  # moving elevator: move up/down one floor
            y = elv['y']
            dt = 30 if y == 1 else 5                        # delay caused by pickup/dropoff
            delay += 1                                      # move 1 floor/second
        rdr = rider()                                       # represent unique rider as randomly generated 7 char rider id
        print('picked up rider: {} from {}'.format(rdr, a)) # [debug]
        elv['rdrs'].update( {rdr:True} )                    # pick the the rider
        delay += 1                                          # "wait for pick-up to finish"
        pass                                                # add to hash of riders to be dropped off
    t += 1