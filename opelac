#!/usr/bin/env python3 -B
from numpy import loadtxt, mean, array
import sys, io, random, string

try:
    CALLS = io.StringIO('\n'.join(line.strip() for line in sys.stdin))
except:
    exit('usage: [CALLS] | opelac\nor: opelac < [CALLS_FILE]')

data = loadtxt(fname=CALLS, dtype=('i'))                        # load data into 2D array: [(t, a, b), ...]
calls = {t: (a,b) for t,a,b in data}                            # hash map => {t: (a, b)}

NUM_SHAFTS = 3                                                  # number of elevators
CAPACITY = 10                                                   # maximum capacity of each elevator
elv = {
    'y': 1,                                                     # the position of the elevator
    'riders': {},                                               # hash map => {rider: True}
    'delay': 0,                                                 # the amount of time by which elevator movement should be delayed
    'v': 0                                                      # the velocity (speed and direction) of the elevator
}
elv = {idx: elv.copy() for idx in range(NUM_SHAFTS)}            # (NUM_SHAFTS) identical elevators

waiting = {}                                                    # {a: [rider, ...]}
destination = {}                                                # {rider: b}
arriving = {}                                                   # {b: [rider, ...]}
ignore = {idx: {} for idx in range(NUM_SHAFTS)}                 # {idx: {y: True, ...}, ...}

position = lambda idx: elv[idx]['y']                            # get: position of elevator
nriders = lambda idx: len(elv[idx]['riders'])                   # get: number of riders inside elevator
limit = lambda idx: CAPACITY - nriders(idx)                     # get: number of additional riders that can fit inside elevator
npickup = lambda y: len(waiting[y])                             # get: number of people to be riders up at y
velocity = lambda idx: elv[idx]['v']                            # get: velocity of elevator
delayed = lambda idx: elv[idx]['delay']                         # get: remaining time for which the elevator cannot move

log = {'C': 0, 'P': 0, 'D': 0}                                  # store number of calls, pick-ups, and drop-offs

t = 0
delay = 0

def advance():                                                  # move time forward; set next velocity
    global t
    dt = 1
    for idx in range(NUM_SHAFTS):
        pos = position(idx)
        v = velocity(idx)
        if delayed(idx):                                        # is performing pickup/dropoff
            v = 0
            elv[idx]['delay'] -= dt
        elif velocity(idx):                                     # is moving
            if pos == 1:
                v = 1                                           # change velocity to 1 floor/second
            elif pos == 100:                              
                v = -1                                          # change velocity to -1 floor/second
        else:                                                   # is stationairy
            v = 1
        elv[idx]['v'] = v                                       # set velocity
        elv[idx]['y'] += v                                      # move elevator
    t += dt                                                     # time moves forward no matter what

def rider():                                                    # generate unique rider identifier
    chars = string.ascii_lowercase + string.digits
    r = ''.join(random.choice(chars) for i in range(25))
    return r

def respond(call):
    log['C'] += 1
    r = rider()                                                 # unique rider for each call (r)
    a, b = call                                             
    waiting[a] = waiting.get(a, []) + [r]                       # (r) is waiting at (a)
    destination[r] = b                                          # (r) is going to (b)

def pickup(idx, riders):
    global delay
    for r in riders:
        log['P'] += 1
        elv[idx]['riders'][r] = True                            # rider steps into elevator
        b = destination[r]                                      # rider is going to (b)
        arriving[b] = arriving.get(b, []) + [r]                 # at (b), dropoff (r)
    assert nriders(idx) <= CAPACITY
    dt = 30 if position(idx) == 1 else 5                        # compensate for time it takes to pick up riders
    delay += dt; elv[idx]['delay'] += dt

def dropoff(idx, riders):
    global delay
    for r in riders:
        log['D'] += 1
        elv[idx]['riders'].pop(r)                               # disembark riders by their unique identifer
    dt = 30 if position(idx) == 1 else 5                        # compensate for time it takes to drop off riders
    delay += dt; elv[idx]['delay'] += dt
    ignore[idx].clear()                                         # clear ignore table after every dropoff

while calls or waiting or arriving:
    if calls.get(t):                                            # check if call was made at current time)
        respond( calls.pop(t) )
    for idx in range(NUM_SHAFTS):
        y = position(idx)
        if arriving.get(y):                                     # (1) check if rider(s) needs to be dropped off at current position  
            dropoff( idx, arriving.pop(y) )
        if waiting.get(y) and not ignore[idx].get(y):           # (2) check if rider(s) needs to be picked up at current position
            lmt = limit(idx)
            if npickup(y) <= lmt:                               # if there is enough space
                pickup( idx, waiting.pop(y) )                   # pick-up all riders
            else:                                               # if there is not enough space
                pickup( idx, waiting[y][:lmt] )                 # pick up only (lmt) people
                waiting[y] = waiting[y][lmt:]                   # update waiting table
                ignore[idx][y] = True                           # ignore this floor until next dropoff
    advance()

assert all(nriders(idx) == 0 for idx in range(NUM_SHAFTS))
assert len(data) == log['C'] == log['P'] == log['D']
print('t:', t, 'delay:', delay)