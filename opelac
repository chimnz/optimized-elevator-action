#!/usr/bin/python3 -B
from numpy import loadtxt, mean, array
from sys import argv

try:
    CALLS_FILE = argv[1]  									# path to input file => {t} {pos} {dest} on each line
    OUT_FILE = argv[2]										# path to output file
    NUM_SHAFTS = int(argv[3])                               # specify number of shafts
except:
    exit('usage : opelac [CALLS_FILE] [OUT_FILE] [NUM_SHAFTS]')

INITIAL_POS = 1											# initial shaft position
SPEED = 1												# shaft speed
TIME = 0

EXEC_MSG = "TIME {};\tSHAFT {} FLOOR {} -> {}\t{}"
STAT_MSG = "AVG_WAIT_TIME = {:.2f}\nAVG_INSIDE_TIME = {:.2f}\nAVG_TOTAL_DELAY = {:.2f}"

pickup, dropoff = 'PICKUP', 'DROPOFF'                       # the two types of "goto" actions
action_log = []                                             # action message log
dt1_log = { pickup: [], dropoff: [] }                       # dt1 is "wait time" for pickup and "inside time" for dropoff
es = {}                                                     # init elevator system state
for i in range(NUM_SHAFTS):
    n = i+1                                                 # shaft number
    shaft = { 'n': n, 'pos': INITIAL_POS }                  # shaft (dict)
    es[n] = shaft

# load data into 2D array
calls = list( loadtxt(fname=CALLS_FILE, dtype=('i')) )
TIME = calls[0][0]
# convert 2D array into 1D array of hash tables
calls = [{'t': t, 'pos': pos, 'dest': dest} for t, pos, dest in calls]

def nearest_shaft(pos):
    distance = lambda shaft: abs( pos - shaft['pos'] )
    shafts = sorted( es.values(), key=distance )
    return shafts[0]['n']

def goto(act, n, pos, dest):
    global TIME
    msg = EXEC_MSG.format(TIME, n, pos, dest, act)          # log message for the action
    action_log.append( msg )

    dt1 = int( abs(dest-pos) / SPEED )                      # delay #1: traveling
    dt1_log[act].append(dt1)
    dt2 = 30 if dest == 1 else 5                            # delay #2: loading/unloading
    TIME += (dt1 + dt2)
    es[n]['pos'] = dest                                     # shaft has reached destination

# process calls list a FIFO queue
while calls:
    call = calls.pop(0)
    call_time = call['t']
    if TIME <= call_time:                                   # if next call has not occured yet
        TIME = call_time                                    # wait until next call before performing actions

    n = nearest_shaft( call['pos'] )                        # choose the nearest shaft
    goto( pickup, n, es[n]['pos'], call['pos'] )            # pickup first
    goto( dropoff, n, call['pos'], call['dest'] )           # then dropoff

# write action time series to output file
with open(OUT_FILE, 'w') as f:
    s = "\n".join(msg for msg in action_log)
    f.write(s)

# compute stats and write to stdout
avg_wait_time = mean( array(dt1_log[pickup]) )
avg_inside_time = mean( dt1_log[dropoff] )
avg_total_delay = avg_wait_time + avg_inside_time
print(STAT_MSG.format(
    avg_wait_time, avg_inside_time, avg_total_delay
))