#!/usr/bin/python3 -B
from numpy import loadtxt, mean, array
from sys import argv

CALLS_FILE = argv[1]  									# path to input file => {t} {pos} {dest} on each line
OUT_FILE = argv[2]										# path to output file

INITIAL_POS = 1											# initial shaft position
SPEED = 1												# shaft speed
TIME = 0

EXEC_MSG = "TIME {}\tFLOOR {} -> {}\t{}"
STAT_MSG = "AVG_WAIT_TIME = {:.2f}\nAVG_INSIDE_TIME = {:.2f}\nAVG_TOTAL_DELAY = {:.2f}"

pickup, dropoff = 'PICKUP', 'DROPOFF'                       # action strings
action_log = []
dt1_log = { pickup: [], dropoff: [] }                       # dt1 is "wait time" for pickup and "inside time" for dropoff
shaft = { 'pos': 1 }                                        # init shaft state (starts at first floor)

# load data into 2D array
calls = list( loadtxt(fname=CALLS_FILE, dtype=('i')) )
TIME = calls[0][0]
# convert 2D array into 1D array of hash tables
calls = [{'t': t, 'pos': pos, 'dest': dest} for t, pos, dest in calls]

def goto(act, pos, dest):
    global TIME
    msg = EXEC_MSG.format(TIME, pos, dest, act)             # log the action that is about to occur
    action_log.append( msg )

    dt1 = int( abs(dest-pos) / SPEED )                      # delay #1: traveling
    dt1_log[act].append(dt1)
    dt2 = 30 if dest == 1 else 5                            # delay #2: loading/unloading
    TIME += (dt1 + dt2)
    shaft['pos'] = dest                                     # shaft has reached destination

# process FIFO queue
while calls:
    call = calls.pop(0)
    call_time = call['t']
    if TIME <= call_time:                                   # if next call has not happened yet
        TIME = call_time                                    # wait until next call before performing actions
    goto( pickup, shaft['pos'], call['pos'] )      # pickup first
    goto( dropoff, call['pos'], call['dest'] )     # then dropoff

# write action time series to output file
with open(OUT_FILE, 'w') as f:
    s = "\n".join(msg for msg in action_log)
    f.write(s)

# compute stats and write to stdout
avg_wait_time = mean( array(dt1_log[pickup]) )
avg_inside_time = mean( dt1_log[dropoff] )
avg_total_delay = avg_wait_time + avg_inside_time
print(STAT_MSG.format(
    avg_wait_time, avg_inside_time, avg_total_delay
))